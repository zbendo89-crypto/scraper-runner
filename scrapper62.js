const MAX_CONTEXTS = 50;        // real concurrency
const TOTAL_PER_PREFIX = 39304;
const Database = require("better-sqlite3");
const MAX_RUNTIME_MINUTES = 355;
let REQUEST_COUNTER = 0;
const RESTART_THRESHOLD = 2500;
let RESTARTING = false;
let RESTART_REQUESTED = false;
let RECOVERING_403 = false;
let BROWSER_GENERATION = 0;
let POOL_GENERATION = 0;
let IN_FLIGHT = 0;
const BLOCKED_QUEUE = new Set();
const START_TIME = Date.now();
const END_TIME = START_TIME + MAX_RUNTIME_MINUTES * 60 * 1000;
const xml2js = require("xml2js");
let STOP_FLAG = false;
let BLOCKED_CODE = null;
let DEBUG_COUNTER = 0;

let stats = {
  ok: 0,
  forbidden: 0,
  other: 0,
  done: 0
};

let GLOBAL_PAUSE = false;


async function waitIfPaused() {
  if (!GLOBAL_PAUSE) return;
  while (GLOBAL_PAUSE) {
    await new Promise(r => setTimeout(r, 50));
  }
}


const nodemailer = require("nodemailer");
const fs = require("fs");

async function sendDbViaGmail() {
  const dbPath = "OUTPUT.db";

  if (!fs.existsSync(dbPath)) {
    console.log("üì≠ OUTPUT.db not found. No email sent.");
    return;
  }

  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: "1btcryptopayment@gmail.com",
      pass: "zjti bewf hoib dteb"
    }
  });

  await transporter.sendMail({
    from: "1btcryptopayment@gmail.com",
    to: "tidianeyonkeu515@gmail.com",
    subject: "sportybet Script Output DB",
    text: "Attached is the OUTPUT.db generated by the script.",
    attachments: [
      {
        filename: "OUTPUT.db",
        path: dbPath
      }
    ]
  });

  console.log("üìß OUTPUT.db sent successfully via Gmail.");
}

const { Worker, isMainThread, parentPort, workerData } = require("worker_threads");

if (!isMainThread && workerData === "DB_WORKER") {
  // ==========================
  // DATABASE WORKER
  // ==========================
  const db = new Database("OUTPUT.db");

  db.exec(`
    PRAGMA journal_mode = WAL;
    PRAGMA synchronous = NORMAL;
    PRAGMA temp_store = MEMORY;
    PRAGMA cache_size = -50000;

    CREATE TABLE IF NOT EXISTS codes (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      worker_id TEXT,
      label TEXT,
      code TEXT UNIQUE,
      teams TEXT,
      events TEXT,
      score TEXT,
      times TEXT,
      odds TEXT,
      total_odds TEXT,
      last_change TEXT,
      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
    );
  `);

  const insert = db.prepare(`
    INSERT OR IGNORE INTO codes
    (worker_id,label,code,teams,events,score,times,odds,total_odds,last_change)
    VALUES (?,?,?,?,?,?,?,?,?,?)
  `);

  let buffer = [];

  function flush() {
    if (buffer.length === 0) return;
    const tx = db.transaction(rows => {
      for (const r of rows) insert.run(...r);
    });
    tx(buffer);
    buffer = [];
  }

  parentPort.on("message", msg => {
    if (msg === "flush") {
      flush();
      return;
    }
    buffer.push(msg);
    if (buffer.length >= 500) flush();
  });

  setInterval(flush, 200);

  console.log("üóÑÔ∏è  DB Worker ready");
  return;
}

// ==========================
// MAIN THREAD
// ==========================
let dbWorker;
if (isMainThread) {
  dbWorker = new Worker(__filename, { workerData: "DB_WORKER" });
}

// Function to log codes to DB worker
function logCode(label, code, workerId, teams, events, score, times, odds, totalOdds, lastChange) {
  if (dbWorker) {
    dbWorker.postMessage([workerId, label, code, teams, events, score, times, odds, totalOdds, lastChange]);
  }
}
// Function to flush DB worker (call on shutdown)
async function flushDbWorker() {
  if (!dbWorker) return;
  dbWorker.postMessage("flush");
  await new Promise(r => setTimeout(r, 1000)); // give time to flush
}

function runtimeWatchdog() {
  const interval = setInterval(() => {
    if (Date.now() >= END_TIME) {
      console.log("‚è∞ MAX EXECUTION TIME REACHED ‚Äî STOPPING SCRIPT");
      STOP_FLAG = true;
      clearInterval(interval);
    }
  }, 1000);
}

function logStatus(code, status) {
  let color;
  let label = status;

  if (status === 200) {
    color = "\x1b[32m"; // green
    stats.ok++;
  } else if (status === 403) {
    color = "\x1b[31m"; // red
    stats.forbidden++;
  } else {
    color = "\x1b[33m"; // yellow
    stats.other++;
  }

  stats.done++;

  console.log(
    `${color}[${code}] ‚Üí ${label}\x1b[0m ` +
    `| DONE ${stats.done}/${TOTAL_PER_PREFIX} ` +
    `OK=${stats.ok} 403=${stats.forbidden} OTHER=${stats.other}`
  );
}

const SUFFIX_CHARS = ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","J","K","L","M","N","P","Q","R","S","T","U","V","W","X","Y","Z"];

function generateCodes(prefix) {
  const out = [];

  for (const a of SUFFIX_CHARS) {
    for (const b of SUFFIX_CHARS) {
      for (const c of SUFFIX_CHARS) {
        out.push(`${prefix}${a}${b}${c}`);
      }
    }
  }

  return out;
}

function randomContextOptions() {
  const userAgents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/124.0.0.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 13_5) Chrome/125.0.0.0",
    "Mozilla/5.0 (X11; Linux x86_64) Firefox/118.0",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) Safari/604.1"
  ];

  const timezones = [
    "America/New_York",
    "Europe/London",
    "Africa/Lagos",
    "Europe/Paris",
    "Asia/Singapore"
  ];

  return {
    userAgent: userAgents[Math.floor(Math.random() * userAgents.length)],
    viewport: {
      width: 1100 + Math.floor(Math.random() * 500),
      height: 700 + Math.floor(Math.random() * 400)
    },
    locale: ["en-US", "en-GB", "fr-FR"][Math.floor(Math.random() * 3)],
    timezoneId: timezones[Math.floor(Math.random() * timezones.length)],
    deviceScaleFactor: [1, 1.25, 1.5][Math.floor(Math.random() * 3)],
    colorScheme: Math.random() > 0.5 ? "dark" : "light"
  };
}

class ContextPool {
  constructor(browser, size) {
    this.browser = browser;
    this.size = size;
    this.pool = [];
    this.queue = [];
  }

  async init() {
    for (let i = 0; i < this.size; i++) {
      const ctx = await this.browser.newContext(randomContextOptions());
      this.pool.push(ctx);
      this.queue.push(ctx);
    }
  }

  async acquire() {
  while (this.queue.length === 0 && !STOP_FLAG) {
    await new Promise(r => setTimeout(r, 5));
  }

  if (STOP_FLAG) throw new Error("Pool stopped");

  const ctx = this.queue.pop();
  ctx.__poolGen = POOL_GENERATION;   // üîë
  return ctx;
}




  release(ctx) {
    this.queue.push(ctx);
  }

  async close() {
    for (const ctx of this.pool) {
      await ctx.close();
    }
  }
}

async function restartBrowserAndPool(state) {
  if (RESTARTING) return;

  RESTARTING = true;

  console.log("\nüîÑ SAFE RESTART (waiting workers idle)...\n");

  // allow in-flight requests to finish
  await new Promise(r => setTimeout(r, 200));

  await state.pool.close();
  await state.browser.close();

  state.browser = await chromium.launch({
    headless: true,
    args: ["--disable-blink-features=AutomationControlled", "--no-sandbox"]
  });

  state.pool = new ContextPool(state.browser, MAX_CONTEXTS);
  await state.pool.init();

  REQUEST_COUNTER = 0;

  console.log("‚úÖ Restart complete\n");

  RESTARTING = false;
}

async function fetchCode(ctx, code, state) {

  // ‚õî hard pause barrier
  await waitIfPaused();

  // üö´ reject stale contexts
  if (ctx.__poolGen !== POOL_GENERATION) {
    return "STALE";
  }

  IN_FLIGHT++; // üîí mark request active

  try {
    await waitIfPaused(); // double guard

    const resp = await ctx.request.get(
      `https://www.sportybet.com/api/ng/orders/share/${code}`,
      {
        timeout: 30000,
        headers: {
          "Accept": "application/json, text/plain, */*",
          "Referer": "https://www.sportybet.com/en"
        }
      }
    );

    const status = resp.status();

    // üö® 403 HANDLING (QUEUE, NOT OVERWRITE)
    if (status === 403) {
      BLOCKED_QUEUE.add(code);
      logStatus(code, 403);

      console.log("üö® 403 detected ‚Äî queued for recovery");

      try { await ctx.close(); } catch {}

      recoverFrom403(state);
      return "403";
    }

    // ‚ùå non-200
    if (status !== 200) {
      logStatus(code, status);
      return;
    }

    // ‚úÖ success
    

try {
    const contentType = resp.headers()["content-type"] || "";
    const text = await resp.text();

    // ==========================
    // JSON RESPONSE
    // ==========================
    if (contentType.includes("application/json")) {
        let jsonObj;
        try {
            jsonObj = JSON.parse(text);
        } catch (e) {
            console.log(`[${code}] JSON parse error`);
            return;
        }

        await processResponse(jsonObj, code, "JS");
        return;
    }

    // ==========================
    // XML RESPONSE (Python Equivalent)
    // ==========================
    if (text.startsWith("<BaseRsp")) {

        const parser = new xml2js.Parser({
            explicitArray: false,
            mergeAttrs: true
        });

        let result;
        try {
            result = await parser.parseStringPromise(text);
        } catch (err) {
            console.log(`[${code}] XML parse failed`);
            return;
        }

        const message = result?.BaseRsp?.message;
        if (message !== "Success") {
            return;
        }

        let outcomes = result?.BaseRsp?.data?.outcomes?.outcomes;
        if (!outcomes) return;

        if (!Array.isArray(outcomes)) {
            outcomes = [outcomes];
        }

        // Convert XML structure to JSON-like format
        const normalized = {
            message: "Success",
            data: {
                outcomes: outcomes.map(o => ({
                    matchStatus: o.matchStatus,
                    estimateStartTime: Number(o.estimateStartTime),
                    homeTeamName: o.homeTeamName,
                    awayTeamName: o.awayTeamName,
                    sport: {
                        name: o?.sport?.name,
                        category: {
                            name: o?.sport?.category?.name
                        }
                    },
                    markets: [{
                        desc: o?.markets?.markets?.desc,
                        lastOddsChangeTime: Number(o?.markets?.markets?.lastOddsChangeTime),
                        outcomes: [{
                            desc: o?.markets?.markets?.outcomes?.outcomes?.desc,
                            odds: Number(o?.markets?.markets?.outcomes?.outcomes?.odds)
                        }]
                    }]
                }))
            }
        };

        await processResponse(normalized, code, "XML");
        return;
    }

    console.log(`[${code}] Unknown response format`);
} catch (err) {
    console.log(`[${code}] Response handling error: ${err.message}`);
}
finally {
      try { resp.dispose?.(); } catch {}
    }

  } catch (err) {
    stats.done++;
    stats.other++;
    console.log(
      `\x1b[35m[${code}] ‚Üí ERROR (${err.message})\x1b[0m | DONE ${stats.done}/${TOTAL_PER_PREFIX}`
    );
  } finally {
    IN_FLIGHT--; // üîì request finished
  }

  REQUEST_COUNTER++;
}



function processResponse(response, local_code, session_id = "JS") {
  if (!response) return false;

  if (response.message === "The code is invalid.") {

    return "INVALID";
  }

  if (response.message !== "Success") {

    return false;
  }

  const pg = response.data?.outcomes;
  if (!pg) return false;

  const number_of_event = pg.length;
  if (number_of_event === 0) {

    return "VALID";
  }

  // --- Memory-safe arrays ---
  const events_status = [];
  const datetimestamp = [];
  const match_date = [];
  const odds = [];
  const sports = [];
  const lst_events = [];
  const lst_match_time = [];
  const lst_scores = [];
  const lst_teams = [];
  const lst_change = [];
  const lst_match_oddchanges = [];
  const lst_type = [];

  const today_date = new Date().toDateString();

  try {
    for (let i = 0; i < number_of_event; i++) {
      const e = pg[i];

      // Directly push primitive values to arrays
      events_status.push(e.matchStatus);
      datetimestamp.push(Number(e.estimateStartTime));
      odds.push(Number(e.markets[0].outcomes[0].odds));
      sports.push(String(e.sport.name));
      lst_type.push(String(e.sport.category.name));
      lst_events.push(String(e.markets[0].desc));
      lst_scores.push(String(e.markets[0].outcomes[0].desc));
      lst_teams.push(`${e.homeTeamName} vs ${e.awayTeamName}`);
      lst_change.push(Number(e.markets[0].lastOddsChangeTime));
    }

    for (const ts of datetimestamp) {
      const d = new Date(ts);
      match_date.push(d.toDateString());
      lst_match_time.push(d.toTimeString().split(" ")[0]);
    }

    for (const ch of lst_change) {
      const t = new Date(ch).toTimeString().split(" ")[0];
      lst_match_oddchanges.push(t);
    }

    let result = 1.0;
    for (const o of odds) result *= o;

    const match_times = lst_match_time.join("|");
    const outcomes = lst_scores.join("|");
    const events = lst_events.join("|");
    const var_odd = odds.join("|");
    const total_odd = result.toFixed(2);
    const total_result = Number(result);
    const change_times = lst_match_oddchanges.join("|");
    const teams = lst_teams.join("|");

    if (
      events_status.every(s => ["Not start","H1"].includes(s)) &&
      match_date.every(d => d === today_date) &&
      lst_type.every(t => t !== "Simulated Reality League") &&
      sports.every(s => s === "Football")
    ) {
      if (number_of_event === 4 && total_result > 100 && total_result < 200) {
        logCode("QUADRIPLE", local_code, session_id, teams, events, outcomes, match_times, var_odd, total_odd, change_times);
        return "VALID";
      } else if (number_of_event === 3 && total_result > 18 && total_result < 200) {
        logCode("TRIPLE", local_code, session_id, teams, events, outcomes, match_times, var_odd, total_odd, change_times);
        return "VALID";
      } else if (number_of_event === 2 && total_result > 25 && total_result < 180 &&
                 lst_events.every(e => e === "Correct Score")) {
        logCode("DOUBLE", local_code, session_id, teams, events, outcomes, match_times, var_odd, total_odd, change_times);
        return "VALID";
      } else if (number_of_event === 1 && total_result > 5 && total_result < 30 &&
                 lst_events.every(e => e === "Correct Score")) {
        logCode("SINGLE", local_code, session_id, teams, events, outcomes, match_times, var_odd, total_odd, change_times);
        return "VALID";
      }
    } else {

    }
  } catch (err) {
    console.log(err, `1----${local_code}`);
  } finally {
    // --- Memory cleanup ---
    [pg, events_status, datetimestamp, match_date, odds, sports,
     lst_events, lst_match_time, lst_scores, lst_teams,
     lst_change, lst_match_oddchanges, lst_type].forEach(arr => { if (Array.isArray(arr)) arr.length = 0; });

    global.gc?.();
  }

  return false;
}

async function runPrefix(state, prefix) {
  const codes = generateCodes(prefix);
  let index = 0;

  async function worker(workerId) {
    while (true) {

      // ‚è∏ pause during recovery
      while (STOP_FLAG || RECOVERING_403) {
        await new Promise(r => setTimeout(r, 50));
      }

      const i = index++;
      if (i >= codes.length) break;

      let ctx;
      try {
        ctx = await state.pool.acquire();
      } catch {
        continue;
      }

      try {
        const result = await fetchCode(ctx, codes[i], state);

        // üîÅ stale ‚Üí retry with fresh context
        if (result === "STALE") {
          continue;
        }

      } catch (err) {
        console.log(`[${codes[i]}] Worker error: ${err.message}`);
      } finally {

        // ‚úÖ only return valid contexts
        if (ctx && ctx.__poolGen === POOL_GENERATION) {
          try {
            state.pool.release(ctx);
          } catch {}
        } else {
          try {
            await ctx?.close();
          } catch {}
        }
      }
    }
  }

  // üöÄ spawn workers
  const workers = [];
  for (let i = 0; i < MAX_CONTEXTS; i++) {
    workers.push(worker(i));
  }

  await Promise.all(workers);
}


// --------------------
// STOP ALL WORKERS UTILITY
// --------------------
async function stopAllWorkers(state) {
  console.log("‚è∏ Pausing workers...");

  STOP_FLAG = true;

  const start = Date.now();
  const MAX_WAIT = 5000; // give in-flight requests up to 15s to finish

  while (Date.now() - start < MAX_WAIT) {
    const returned = state.pool.queue.length;
    const total = state.pool.size;

    console.log(`Waiting contexts: ${returned}/${total}`);

    if (returned >= total) break;

    await new Promise(r => setTimeout(r, 250));
  }

  console.log(
    `All contexts returned: ${state.pool.queue.length}/${state.pool.size}`
  );

  // Extra grace delay for late network responses
  console.log("‚è≥ Final grace wait for late responses (2s)...");
  await new Promise(r => setTimeout(r, 2000));
}

// --------------------
// 403 RECOVERY FUNCTION
// --------------------
async function recoverFrom403(state) {
  if (RECOVERING_403) return;
  RECOVERING_403 = true;

  console.log("üö® Starting 403 recovery");

  // ‚õî freeze the world
  GLOBAL_PAUSE = true;
  STOP_FLAG = true;

  // ‚è≥ wait for ALL in-flight requests
  while (IN_FLIGHT > 0) {
    await new Promise(r => setTimeout(r, 20));
  }

  console.log("üßä All in-flight requests completed");

  // üî• invalidate all old contexts
  POOL_GENERATION++;

  // üí£ destroy pool + browser
  try { await state.pool.close(); } catch {}
  try { await state.browser.close(); } catch {}

  console.log("‚ôªÔ∏è Browser & pool destroyed");

  // üîÑ rebuild
  state.browser = await chromium.launch({
    headless: true,
    args: ["--disable-blink-features=AutomationControlled", "--no-sandbox"]
  });

  state.pool = new ContextPool(state.browser, MAX_CONTEXTS);
  await state.pool.init();

  console.log("‚úÖ New browser & pool ready");

  // üîÅ retry ALL blocked codes safely
  while (BLOCKED_QUEUE.size > 0) {
    const codes = [...BLOCKED_QUEUE];

    for (const code of codes) {
      let retryBrowser, retryCtx;

      try {
        retryBrowser = await chromium.launch({ headless: true });
        retryCtx = await retryBrowser.newContext(randomContextOptions());

        console.log(`üîÅ Retrying blocked code ${code}`);

        const resp = await retryCtx.request.get(
          `https://www.sportybet.com/api/ng/orders/share/${code}`,
          { timeout: 30000 }
        );

        const status = resp.status();
        console.log(`Retry status: ${status}`);

        if (status === 200) {
          console.log(`‚úÖ 403 cleared for ${code}`);
          BLOCKED_QUEUE.delete(code);
        }

      } catch (err) {
        console.log(`Retry error for ${code}: ${err.message}`);
      } finally {
        try { await retryCtx?.close(); } catch {}
        try { await retryBrowser?.close(); } catch {}
      }

      await new Promise(r => setTimeout(r, 3000)); // cooldown
    }

    if (BLOCKED_QUEUE.size > 0) {
      await new Promise(r => setTimeout(r, 1000));
    }
  }

  // ‚ñ∂ resume everything
  STOP_FLAG = false;
  GLOBAL_PAUSE = false;
  RECOVERING_403 = false;

  console.log("‚ñ∂ Workers resumed ‚Äî full concurrency restored");
}





const { chromium } = require("playwright");

(async () => {

  runtimeWatchdog();

  try {
    const PREFIXES = [
    "TJV",
    "UWR",
    "JYB",
    "UXC",
    "TKG",
    "UXZ",
    "TF6",
    "Q14",
    "MZC",
    "JYY",
    "UYL",
    "TLP",
    "Q24",
    "Q2R",
    "K06"
];

    const state = {};

    state.browser = await chromium.launch({
      headless: true,
      args: ["--disable-blink-features=AutomationControlled", "--no-sandbox"]
    });

    state.pool = new ContextPool(state.browser, MAX_CONTEXTS);
    await state.pool.init();


    for (const prefix of PREFIXES) {
      console.log(`üöÄ Processing prefix ${prefix}`);

      stats = { ok: 0, forbidden: 0, other: 0, done: 0 };

      await runPrefix(state, prefix);
    }

    await state.pool.close();
    await state.browser.close();


  } finally {
    dbWorker.postMessage("flush");

    // give DB worker time to flush
    await new Promise(r => setTimeout(r, 1000));

    await sendDbViaGmail();

    process.exit(0);
  }
})();


